import DataLoader from "dataloader";
import { Redis } from "ioredis";
import { Db } from "mongodb";
import uuid from "uuid";

import { EventEmitter } from "events";
import logger from "talk-server/logger";
import {
  retrieveAllTenants,
  retrieveManyTenants,
  retrieveManyTenantsByDomain,
  Tenant,
} from "talk-server/models/tenant";

const TENANT_UPDATE_CHANNEL = "tenant";

const EMITTER_EVENT_NAME = "update";

export type SubscribeCallback = (tenant: Tenant) => void;

interface TenantUpdateMessage {
  tenant: Tenant;
  clientApplicationID: string;
}

// TenantCache provides an interface for retrieving tenant stored in local
// memory rather than grabbing it from the database every single call.
export default class TenantCache {
  /**
   * tenantsByID reference the tenants that have been cached/retrieved by ID.
   */
  private tenantsByID = new DataLoader<string, Readonly<Tenant> | null>(ids => {
    logger.debug({ ids: ids.length }, "now loading tenants");
    return retrieveManyTenants(this.mongo, ids);
  });

  /**
   * tenantsByDomain reference the tenants that have been cached/retrieved by
   * Domain.
   */
  private tenantsByDomain = new DataLoader<string, Readonly<Tenant> | null>(
    domains => {
      logger.debug({ domains: domains.length }, "now loading tenants");
      return retrieveManyTenantsByDomain(this.mongo, domains);
    }
  );

  /**
   * Create a new client application ID. This prevents duplicated messages
   * generated by this application from being handled as external messages
   * as we should have already processed it.
   */
  private clientApplicationID = uuid.v4();

  private mongo: Db;
  private emitter = new EventEmitter();

  constructor(mongo: Db, subscriber: Redis) {
    // Save the Db reference.
    this.mongo = mongo;

    // Attach to messages on this connection so we can receive updates when
    // the tenant are changed.
    subscriber.on("message", this.onMessage);

    // Subscribe to tenant notifications.
    subscriber.subscribe(TENANT_UPDATE_CHANNEL);
  }

  /**
   * primeAll will load all the tenants into the cache on startup.
   */
  public async primeAll() {
    // Grab all the tenants for this node.
    const tenants = await retrieveAllTenants(this.mongo);

    // Clear out all the items in the cache.
    this.tenantsByID.clearAll();
    this.tenantsByDomain.clearAll();

    // Prime the cache with each of these tenants.
    tenants.forEach(tenant => {
      this.tenantsByID.prime(tenant.id, tenant);
      this.tenantsByDomain.prime(tenant.domain, tenant);
    });

    logger.debug({ tenants: tenants.length }, "primed tenants");
  }

  /**
   *  onMessage is fired every time the client gets a subscription event.
   */
  private onMessage = async (
    channel: string,
    message: string
  ): Promise<void> => {
    // Only do things when the message is for tenant.
    if (channel !== TENANT_UPDATE_CHANNEL) {
      return;
    }

    try {
      // Updated tenant come from the messages.
      const { tenant, clientApplicationID }: TenantUpdateMessage = JSON.parse(
        message
      );

      // Check to see if this was the update issued by this instance.
      if (clientApplicationID === this.clientApplicationID) {
        // It was, so just return here, we already updated/handled it.
        return;
      }

      logger.debug({ tenant_id: tenant.id }, "received updated tenant");

      // Update the tenant cache.
      this.tenantsByID.clear(tenant.id).prime(tenant.id, tenant);
      this.tenantsByDomain.clear(tenant.domain).prime(tenant.domain, tenant);

      // Publish the event for the connected listeners.
      this.emitter.emit(EMITTER_EVENT_NAME, tenant);
    } catch (err) {
      logger.error(
        { err },
        "an error occurred while trying to parse/prime the tenant/tenant cache"
      );
    }
  };

  public async retrieveByID(id: string): Promise<Readonly<Tenant> | null> {
    return this.tenantsByID.load(id);
  }

  public async retrieveByDomain(
    domain: string
  ): Promise<Readonly<Tenant> | null> {
    return this.tenantsByDomain.load(domain);
  }

  /**
   * This allows you to subscribe to new Tenant updates. This will also return
   * a function that when called, unsubscribes you from updates.
   *
   * @param callback the function to be called when there is an updated Tenant.
   */
  public subscribe(callback: SubscribeCallback) {
    this.emitter.on(EMITTER_EVENT_NAME, callback);

    // Return the unsubscribe function.
    return () => {
      this.emitter.removeListener(EMITTER_EVENT_NAME, callback);
    };
  }

  /**
   * update will update the value for Tenant in the local cache and publish
   * a change notification that will be used to keep the other nodes in sync.
   *
   * @param conn a redis connection used to publish the change notification
   * @param tenant the updated Tenant object
   */
  public async update(conn: Redis, tenant: Tenant): Promise<void> {
    // Update the tenant in the local cache.
    this.tenantsByID.clear(tenant.id).prime(tenant.id, tenant);
    this.tenantsByDomain.clear(tenant.domain).prime(tenant.domain, tenant);

    // Notify the other nodes about the tenant change.
    const message: TenantUpdateMessage = {
      tenant,
      clientApplicationID: this.clientApplicationID,
    };

    const subscribers = await conn.publish(
      TENANT_UPDATE_CHANNEL,
      JSON.stringify(message)
    );

    logger.debug({ tenant_id: tenant.id, subscribers }, "updated tenant");

    // Publish the event for the connected listeners.
    this.emitter.emit(EMITTER_EVENT_NAME, tenant);
  }
}
