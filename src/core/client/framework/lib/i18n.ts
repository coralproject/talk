import "fluent-intl-polyfill/compat";
import { negotiateLanguages as negotiate } from "fluent-langneg/compat";
import { FluentBundle } from "fluent/compat";

export interface BundledLocales {
  [locale: string]: string;
}

export interface LoadableLocales {
  [locale: string]: (() => Promise<string>);
}

/**
 * This type describes the shape of the generated code from our `locales-loader`.
 * Please check `./src/loaders` and the webpack config for more information.
 */
export interface LocalesData {
  readonly defaultLocale: string;
  readonly fallbackLocale: string;
  readonly availableLocales: ReadonlyArray<string>;
  readonly bundled: BundledLocales;
  readonly loadables: LoadableLocales;
}

/**
 * negotiateLanguages accepts `userLocales` which usually comes from
 * `navigator.languages` and the locales `data` as generated by
 * the `locales-loader` and returns an array of matching languages.
 */
export function negotiateLanguages(
  userLocales: ReadonlyArray<string>,
  data: LocalesData
) {
  // Choose locale that is best for the user.
  const languages = negotiate(userLocales, data.availableLocales, {
    defaultLocale: data.defaultLocale,
    strategy: "lookup",
  });

  if (data.fallbackLocale && languages[0] !== data.fallbackLocale) {
    // Use default locale as fallback in case we have
    // missing keys.
    languages.push(data.fallbackLocale);
  }

  return languages;
}

// Don't warn in production.
let decorateWarnMissing = (bundle: FluentBundle) => bundle;

// Warn about missing locales if we are not in production.
if (process.env.NODE_ENV !== "production") {
  decorateWarnMissing = (() => {
    const warnings: string[] = [];
    return (bundle: FluentBundle) => {
      const original = bundle.hasMessage;
      bundle.hasMessage = (id: string) => {
        const result = original.apply(bundle, [id]);
        if (!result) {
          const warn = `${
            bundle.locales
          } translation for key "${id}" not found`;
          if (!warnings.includes(warn)) {
            // tslint:disable:next-line: no-console
            console.warn(warn);
            warnings.push(warn);
          }
        }
        return result;
      };
      return bundle;
    };
  })();
}

/**
 * Given a locales array and the `data` from the `locales-loader`,
 * generateMessages returns an Array of MessageContext as a Promise.
 * This array is meant to be consumed by `react-fluent`.
 *
 * Use it in conjunction with `negotiateLanguages`.
 */
export async function generateBundles(
  locales: ReadonlyArray<string>,
  data: LocalesData
): Promise<FluentBundle[]> {
  const promises = [];

  for (const locale of locales) {
    const bundle = new FluentBundle(locale);
    if (locale in data.bundled) {
      bundle.addMessages(data.bundled[locale]);
      promises.push(decorateWarnMissing(bundle));
    } else if (locale in data.loadables) {
      const content = await data.loadables[locale]();
      bundle.addMessages(content);
      promises.push(decorateWarnMissing(bundle));
    } else {
      throw Error(`Locale ${locale} not available`);
    }
  }

  return await Promise.all(promises);
}
