import { Child as PymChild } from "pym.js";
import React from "react";
import { graphql, RelayPaginationProp } from "react-relay";

import { withContext } from "talk-framework/lib/bootstrap";
import { withPaginationContainer } from "talk-framework/lib/relay";
import { ConversationThreadContainer_comment as CommentData } from "talk-stream/__generated__/ConversationThreadContainer_comment.graphql";
import { ConversationThreadContainer_me as MeData } from "talk-stream/__generated__/ConversationThreadContainer_me.graphql";
import { ConversationThreadContainer_settings as SettingsData } from "talk-stream/__generated__/ConversationThreadContainer_settings.graphql";
import { ConversationThreadContainer_story as StoryData } from "talk-stream/__generated__/ConversationThreadContainer_story.graphql";
import { ConversationThreadContainerPaginationQueryVariables } from "talk-stream/__generated__/ConversationThreadContainerPaginationQuery.graphql";
import {
  SetCommentIDMutation,
  withSetCommentIDMutation,
} from "talk-stream/mutations";

import ConversationThread from "../components/ConversationThread";

interface ConversationThreadContainerProps {
  comment: CommentData;
  story: StoryData;
  settings: SettingsData;
  me: MeData | null;
  setCommentID: SetCommentIDMutation;
  pym: PymChild | undefined;
  relay: RelayPaginationProp;
}

class ConversationThreadContainer extends React.Component<
  ConversationThreadContainerProps
> {
  public state = {
    disableLoadMore: false,
  };

  private loadMore = () => {
    if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {
      return;
    }
    this.setState({ disableLoadMore: true });
    this.props.relay.loadMore(
      5, // Fetch the next 5 feed items
      error => {
        this.setState({ disableLoadMore: false });
        if (error) {
          // tslint:disable-next-line:no-console
          console.error(error);
        }
      }
    );
  };

  public render() {
    const { comment, story, me, settings } = this.props;
    const hasMore = this.props.relay.hasMore();
    return (
      <ConversationThread
        me={me}
        story={story}
        comment={comment}
        settings={settings}
        parents={comment.parents.edges.map(edge => edge.node)}
        disableLoadMore={this.state.disableLoadMore}
        loadMore={this.loadMore}
        remaining={comment.parentCount - comment.parents.edges.length}
        rootParent={
          (hasMore &&
            comment &&
            comment.rootParent && {
              id: comment.rootParent.id,
              createdAt: comment.rootParent.createdAt,
              username:
                comment.rootParent.author && comment.rootParent.author.username,
            }) ||
          null
        }
      />
    );
  }
}

// TODO: (cvle) This should be autogenerated.
interface FragmentVariables {
  count: number;
  cursor?: string;
}

const enhanced = withContext(ctx => ({
  pym: ctx.pym,
}))(
  withSetCommentIDMutation(
    withPaginationContainer<
      ConversationThreadContainerProps,
      ConversationThreadContainerPaginationQueryVariables,
      FragmentVariables
    >(
      {
        story: graphql`
          fragment ConversationThreadContainer_story on Story {
            ...CommentContainer_story
            ...LocalReplyListContainer_story
          }
        `,
        settings: graphql`
          fragment ConversationThreadContainer_settings on Settings {
            ...CommentContainer_settings
            ...LocalReplyListContainer_settings
          }
        `,
        comment: graphql`
          fragment ConversationThreadContainer_comment on Comment
            @argumentDefinitions(
              count: { type: "Int!", defaultValue: 0 }
              cursor: { type: "Cursor" }
            ) {
            id
            ...CommentContainer_comment
            rootParent {
              id
              author {
                id
                username
              }
              createdAt
            }
            parentCount
            parents(last: $count, before: $cursor)
              @connection(key: "ConversationThread_parents") {
              edges {
                node {
                  id
                  ...CommentContainer_comment
                  ...LocalReplyListContainer_comment
                }
              }
            }
          }
        `,
        me: graphql`
          fragment ConversationThreadContainer_me on User {
            ...CommentContainer_me
            ...LocalReplyListContainer_me
          }
        `,
      },
      {
        direction: "backward",
        getConnectionFromProps(props) {
          return props.comment && props.comment.parents;
        },
        // This is also the default implementation of `getFragmentVariables` if it isn't provided.
        getFragmentVariables(prevVars, totalCount) {
          return {
            ...prevVars,
            count: totalCount,
          };
        },
        getVariables(props, { count, cursor }) {
          return {
            count,
            cursor,
            // commentID isn't specified as an @argument for the fragment, but it should be a
            // variable available for the fragment under the query root.
            commentID: props.comment.id,
          };
        },
        query: graphql`
          # Pagination query to be fetched upon calling 'loadMore'.
          # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
          query ConversationThreadContainerPaginationQuery(
            $count: Int!
            $cursor: Cursor
            $commentID: ID!
          ) {
            comment(id: $commentID) {
              ...ConversationThreadContainer_comment
                @arguments(count: $count, cursor: $cursor)
            }
          }
        `,
      }
    )(ConversationThreadContainer)
  )
);

export default enhanced;
