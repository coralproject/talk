import { RouteProps } from "found";
import React from "react";
import { graphql, GraphQLTaggedNode, RelayPaginationProp } from "react-relay";

import { QueueContainer_queue as QueueData } from "talk-admin/__generated__/QueueContainer_queue.graphql";
import { QueueContainer_settings as SettingsData } from "talk-admin/__generated__/QueueContainer_settings.graphql";
import { QueueContainerPaginationPendingQueryVariables } from "talk-admin/__generated__/QueueContainerPaginationPendingQuery.graphql";
import { IntersectionProvider } from "talk-framework/lib/intersection";
import { withPaginationContainer } from "talk-framework/lib/relay";

import LoadingQueue from "../components/LoadingQueue";
import Queue from "../components/Queue";

interface QueueContainerProps {
  queue: QueueData;
  settings: SettingsData;
  relay: RelayPaginationProp;
}

// TODO: use generated types
const danglingLogic = (status: string) =>
  ["ACCEPTED", "REJECTED"].indexOf(status) >= 0;

export class QueueContainer extends React.Component<QueueContainerProps> {
  public static routeConfig: RouteProps;

  public state = {
    disableLoadMore: false,
  };

  public render() {
    const comments = this.props.queue.comments.edges.map(edge => edge.node);
    return (
      <IntersectionProvider>
        <Queue
          comments={comments}
          settings={this.props.settings}
          onLoadMore={this.loadMore}
          hasMore={this.props.relay.hasMore()}
          disableLoadMore={this.state.disableLoadMore}
          danglingLogic={danglingLogic}
        />
      </IntersectionProvider>
    );
  }

  private loadMore = () => {
    if (!this.props.relay.hasMore() || this.props.relay.isLoading()) {
      return;
    }
    this.setState({ disableLoadMore: true });
    this.props.relay.loadMore(
      10, // Fetch the next 10 feed items
      error => {
        this.setState({ disableLoadMore: false });
        if (error) {
          // tslint:disable-next-line:no-console
          console.error(error);
        }
      }
    );
  };
}

// TODO: (cvle) If this could be autogenerated..
type FragmentVariables = QueueContainerPaginationPendingQueryVariables;

const createQueueContainer = (
  queueQuery: GraphQLTaggedNode,
  paginationQuery: GraphQLTaggedNode
) => {
  const enhanced = (withPaginationContainer<
    QueueContainerProps,
    QueueContainerPaginationPendingQueryVariables,
    FragmentVariables
  >(
    {
      queue: graphql`
        fragment QueueContainer_queue on ModerationQueue
          @argumentDefinitions(
            count: { type: "Int!", defaultValue: 5 }
            cursor: { type: "Cursor" }
          ) {
          count
          comments(first: $count, after: $cursor)
            @connection(key: "Queue_comments") {
            edges {
              node {
                id
                ...ModerateCardContainer_comment
              }
            }
          }
        }
      `,
      settings: graphql`
        fragment QueueContainer_settings on Settings {
          ...ModerateCardContainer_settings
        }
      `,
    },
    {
      direction: "forward",
      getConnectionFromProps(props) {
        return props.queue && props.queue.comments;
      },
      // This is also the default implementation of `getFragmentVariables` if it isn't provided.
      getFragmentVariables(prevVars, totalCount) {
        return {
          ...prevVars,
          count: totalCount,
        };
      },
      getVariables(props, { count, cursor }, fragmentVariables) {
        return {
          ...fragmentVariables,
          count,
          cursor,
        };
      },
      query: paginationQuery,
    }
  )(QueueContainer) as any) as typeof QueueContainer;

  enhanced.routeConfig = {
    Component: enhanced,
    query: queueQuery,
    cacheConfig: { force: true },
    render: ({ Component, props }) => {
      const anyProps = props as any;
      if (Component && props) {
        const queue =
          anyProps.moderationQueues[Object.keys(anyProps.moderationQueues)[0]];
        return <Component queue={queue} settings={anyProps.settings} />;
      }
      return <LoadingQueue />;
    },
  };

  return enhanced;
};

export const PendingQueueContainer = createQueueContainer(
  graphql`
    query QueueContainerPendingQuery($storyID: ID) {
      moderationQueues(storyID: $storyID) {
        pending {
          ...QueueContainer_queue
        }
      }
      settings {
        ...QueueContainer_settings
      }
    }
  `,
  graphql`
    # Pagination query to be fetched upon calling 'loadMore'.
    # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
    query QueueContainerPaginationPendingQuery(
      $storyID: ID
      $count: Int!
      $cursor: Cursor
    ) {
      moderationQueues(storyID: $storyID) {
        pending {
          ...QueueContainer_queue @arguments(count: $count, cursor: $cursor)
        }
      }
    }
  `
);

export const ReportedQueueContainer = createQueueContainer(
  graphql`
    query QueueContainerReportedQuery($storyID: ID) {
      moderationQueues(storyID: $storyID) {
        reported {
          ...QueueContainer_queue
        }
      }
      settings {
        ...QueueContainer_settings
      }
    }
  `,
  graphql`
    # Pagination query to be fetched upon calling 'loadMore'.
    # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
    query QueueContainerPaginationReportedQuery(
      $storyID: ID
      $count: Int!
      $cursor: Cursor
    ) {
      moderationQueues(storyID: $storyID) {
        reported {
          ...QueueContainer_queue @arguments(count: $count, cursor: $cursor)
        }
      }
    }
  `
);

export const UnmoderatedQueueContainer = createQueueContainer(
  graphql`
    query QueueContainerUnmoderatedQuery($storyID: ID) {
      moderationQueues(storyID: $storyID) {
        unmoderated {
          ...QueueContainer_queue
        }
      }
      settings {
        ...QueueContainer_settings
      }
    }
  `,
  graphql`
    # Pagination query to be fetched upon calling 'loadMore'.
    # Notice that we re-use our fragment, and the shape of this query matches our fragment spec.
    query QueueContainerPaginationUnmoderatedQuery(
      $storyID: ID
      $count: Int!
      $cursor: Cursor
    ) {
      moderationQueues(storyID: $storyID) {
        unmoderated {
          ...QueueContainer_queue @arguments(count: $count, cursor: $cursor)
        }
      }
    }
  `
);
